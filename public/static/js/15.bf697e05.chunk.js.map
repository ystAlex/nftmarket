{"version":3,"file":"static/js/15.bf697e05.chunk.js","mappings":"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","sources":["../node_modules/iso-url/index.js","../node_modules/iso-url/src/relative.js","../node_modules/iso-url/src/url-browser.js","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bytes.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/vendor/base-x.js","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base58.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base32.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base36.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/vendor/varint.js","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/varint.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/hashes/digest.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/cid.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base10.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base16.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base2.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base256emoji.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base64.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/base8.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/bases/identity.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/codecs/json.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/codecs/raw.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/hashes/identity.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/hashes/hasher.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/hashes/sha2-browser.ts","../node_modules/@multiformats/mafmt/node_modules/multiformats/src/basics.ts","../node_modules/@multiformats/mafmt/node_modules/uint8arrays/src/alloc.ts","../node_modules/@multiformats/mafmt/node_modules/uint8arrays/src/util/bases.ts","../node_modules/@multiformats/mafmt/node_modules/uint8arrays/src/to-string.ts","../node_modules/uint8-varint/src/index.ts","../node_modules/uint8-varint/node_modules/uint8arrays/src/alloc.ts","../node_modules/@multiformats/mafmt/node_modules/uint8arrays/src/concat.ts","../../src/parse.ts","../../src/parser.ts","../node_modules/@chainsafe/netmask/src/ip.ts","../node_modules/@multiformats/mafmt/node_modules/uint8arrays/src/from-string.ts","../../src/is-ip.ts","../node_modules/@multiformats/mafmt/node_modules/@multiformats/multiaddr/src/ip.ts","../node_modules/@multiformats/mafmt/node_modules/@multiformats/multiaddr/src/protocols-table.ts","../node_modules/@multiformats/mafmt/node_modules/@multiformats/multiaddr/src/convert.ts","../node_modules/@multiformats/mafmt/node_modules/@multiformats/multiaddr/src/codec.ts","../node_modules/@multiformats/mafmt/node_modules/@multiformats/multiaddr/src/multiaddr.ts","../node_modules/@multiformats/mafmt/node_modules/uint8arrays/src/equals.ts","../node_modules/@multiformats/mafmt/node_modules/@multiformats/multiaddr/src/index.ts","../node_modules/@multiformats/mafmt/src/index.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bytes.ts","../node_modules/is-ipfs/node_modules/multiformats/src/vendor/base-x.js","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base58.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base32.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base36.ts","../node_modules/is-ipfs/node_modules/multiformats/src/vendor/varint.js","../node_modules/is-ipfs/node_modules/multiformats/src/varint.ts","../node_modules/is-ipfs/node_modules/multiformats/src/hashes/digest.ts","../node_modules/is-ipfs/node_modules/multiformats/src/cid.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base10.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base16.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base2.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base256emoji.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base64.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/base8.ts","../node_modules/is-ipfs/node_modules/multiformats/src/bases/identity.ts","../node_modules/is-ipfs/node_modules/multiformats/src/codecs/json.ts","../node_modules/is-ipfs/node_modules/multiformats/src/codecs/raw.ts","../node_modules/is-ipfs/node_modules/multiformats/src/hashes/identity.ts","../node_modules/is-ipfs/node_modules/multiformats/src/hashes/hasher.ts","../node_modules/is-ipfs/node_modules/multiformats/src/hashes/sha2-browser.ts","../node_modules/is-ipfs/node_modules/multiformats/src/basics.ts","../node_modules/is-ipfs/node_modules/uint8arrays/src/alloc.ts","../node_modules/is-ipfs/node_modules/uint8arrays/src/util/bases.ts","../node_modules/is-ipfs/node_modules/uint8arrays/src/to-string.ts","../node_modules/is-ipfs/node_modules/uint8arrays/src/concat.ts","../node_modules/is-ipfs/node_modules/uint8arrays/src/from-string.ts","../node_modules/is-ipfs/node_modules/@multiformats/multiaddr/src/ip.ts","../node_modules/is-ipfs/node_modules/@multiformats/multiaddr/src/protocols-table.ts","../node_modules/is-ipfs/node_modules/@multiformats/multiaddr/src/convert.ts","../node_modules/is-ipfs/node_modules/@multiformats/multiaddr/src/codec.ts","../node_modules/is-ipfs/node_modules/@multiformats/multiaddr/src/multiaddr.ts","../node_modules/is-ipfs/node_modules/uint8arrays/src/equals.ts","../node_modules/is-ipfs/node_modules/@multiformats/multiaddr/src/index.ts","../node_modules/is-ipfs/src/index.ts"],"sourcesContent":["'use strict'\n\nconst {\n  URLWithLegacySupport,\n  format,\n  URLSearchParams,\n  defaultBase\n} = require('./src/url')\nconst relative = require('./src/relative')\n\nmodule.exports = {\n  URL: URLWithLegacySupport,\n  URLSearchParams,\n  format,\n  relative,\n  defaultBase\n}\n","'use strict'\n\nconst { URLWithLegacySupport, format } = require('./url')\n\n/**\n * @param {string | undefined} url\n * @param {any} [location]\n * @param {any} [protocolMap]\n * @param {any} [defaultProtocol]\n */\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n  let protocol = location.protocol\n    ? location.protocol.replace(':', '')\n    : 'http'\n\n  // Check protocol map\n  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'\n  let urlParsed\n\n  try {\n    urlParsed = new URLWithLegacySupport(url)\n  } catch (err) {\n    urlParsed = {}\n  }\n\n  const base = Object.assign({}, location, {\n    protocol: protocol || urlParsed.protocol,\n    host: location.host || urlParsed.host\n  })\n\n  return new URLWithLegacySupport(url, format(base)).toString()\n}\n","'use strict'\n\nconst isReactNative =\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative'\n\nfunction getDefaultBase () {\n  if (isReactNative) {\n    return 'http://localhost'\n  }\n  // in some environments i.e. cloudflare workers location is not available\n  if (!self.location) {\n    return ''\n  }\n\n  return self.location.protocol + '//' + self.location.host\n}\n\nconst URL = self.URL\nconst defaultBase = getDefaultBase()\n\nclass URLWithLegacySupport {\n  constructor (url = '', base = defaultBase) {\n    this.super = new URL(url, base)\n    this.path = this.pathname + this.search\n    this.auth =\n            this.username && this.password\n              ? this.username + ':' + this.password\n              : null\n\n    this.query =\n            this.search && this.search.startsWith('?')\n              ? this.search.slice(1)\n              : null\n  }\n\n  get hash () {\n    return this.super.hash\n  }\n\n  get host () {\n    return this.super.host\n  }\n\n  get hostname () {\n    return this.super.hostname\n  }\n\n  get href () {\n    return this.super.href\n  }\n\n  get origin () {\n    return this.super.origin\n  }\n\n  get password () {\n    return this.super.password\n  }\n\n  get pathname () {\n    return this.super.pathname\n  }\n\n  get port () {\n    return this.super.port\n  }\n\n  get protocol () {\n    return this.super.protocol\n  }\n\n  get search () {\n    return this.super.search\n  }\n\n  get searchParams () {\n    return this.super.searchParams\n  }\n\n  get username () {\n    return this.super.username\n  }\n\n  set hash (hash) {\n    this.super.hash = hash\n  }\n\n  set host (host) {\n    this.super.host = host\n  }\n\n  set hostname (hostname) {\n    this.super.hostname = hostname\n  }\n\n  set href (href) {\n    this.super.href = href\n  }\n\n  set password (password) {\n    this.super.password = password\n  }\n\n  set pathname (pathname) {\n    this.super.pathname = pathname\n  }\n\n  set port (port) {\n    this.super.port = port\n  }\n\n  set protocol (protocol) {\n    this.super.protocol = protocol\n  }\n\n  set search (search) {\n    this.super.search = search\n  }\n\n  set username (username) {\n    this.super.username = username\n  }\n\n  /**\n   * @param {any} o\n   */\n  static createObjectURL (o) {\n    return URL.createObjectURL(o)\n  }\n\n  /**\n   * @param {string} o\n   */\n  static revokeObjectURL (o) {\n    URL.revokeObjectURL(o)\n  }\n\n  toJSON () {\n    return this.super.toJSON()\n  }\n\n  toString () {\n    return this.super.toString()\n  }\n\n  format () {\n    return this.toString()\n  }\n}\n\n/**\n * @param {string | import('url').UrlObject} obj\n */\nfunction format (obj) {\n  if (typeof obj === 'string') {\n    const url = new URL(obj)\n\n    return url.toString()\n  }\n\n  if (!(obj instanceof URL)) {\n    const userPass =\n            // @ts-ignore its not supported in node but we normalise\n            obj.username && obj.password\n              // @ts-ignore its not supported in node but we normalise\n              ? `${obj.username}:${obj.password}@`\n              : ''\n    const auth = obj.auth ? obj.auth + '@' : ''\n    const port = obj.port ? ':' + obj.port : ''\n    const protocol = obj.protocol ? obj.protocol + '//' : ''\n    const host = obj.host || ''\n    const hostname = obj.hostname || ''\n    const search = obj.search || (obj.query ? '?' + obj.query : '')\n    const hash = obj.hash || ''\n    const pathname = obj.pathname || ''\n    // @ts-ignore - path is not supported in node but we normalise\n    const path = obj.path || pathname + search\n\n    return `${protocol}${userPass || auth}${\n            host || hostname + port\n        }${path}${hash}`\n  }\n}\n\nmodule.exports = {\n  URLWithLegacySupport,\n  URLSearchParams: self.URLSearchParams,\n  defaultBase,\n  format\n}\n","export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabet: string, bitsPerChar: number, name: string): Uint8Array {\n  // Build the character lookup table:\n  const codes: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n","import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n","import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n","import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n","import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n","import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n","import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n","import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array): Digest.Digest<typeof code, number> {\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n","import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n","import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n","import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString (array: Uint8Array, encoding: SupportedEncodings = 'utf8'): string {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // strip multibase prefix\n  return base.encoder.encode(array).substring(1)\n}\n","/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n","import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n",null,null,"import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\n\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\n\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\n\nexport interface IpNetRaw {\n  network: Uint8Array;\n  mask: Uint8Array;\n}\n\nexport function maskIp(ip: Uint8Array, mask: Uint8Array): Uint8Array {\n  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n    mask = mask.slice(12);\n  }\n  if (\n    mask.length === IPv4Len &&\n    ip.length === IPv6Len &&\n    deepEqual(ip, ipv4Prefix, 0, 11)\n  ) {\n    ip = ip.slice(12);\n  }\n  const n = ip.length;\n  if (n != mask.length) {\n    throw new Error(\"Failed to mask ip\");\n  }\n  const out = new Uint8Array(n);\n  for (let i = 0; i < n; i++) {\n    out[i] = ip[i] & mask[i];\n  }\n  return out;\n}\n\nexport function containsIp(\n  net: IpNetRaw,\n  ip: Uint8Array | number[] | string\n): boolean {\n  if (typeof ip === \"string\") {\n    ip = parseIP(ip)!;\n  }\n  if (ip == null) throw new Error(\"Invalid ip\");\n  if (ip.length !== net.network.length) {\n    return false;\n  }\n  for (let i = 0; i < ip.length; i++) {\n    if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function iPv4FromIPv6(ip: Uint8Array): Uint8Array {\n  if (!isIPv4mappedIPv6(ip)) {\n    throw new Error(\"Must have 0xffff prefix\");\n  }\n  return ip.slice(12);\n}\n\nexport function isIPv4mappedIPv6(ip: Uint8Array | number[]): boolean {\n  return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n","import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n",null,"import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport { isIP } from '@chainsafe/is-ip'\nexport const isV4 = isIPv4\nexport const isV6 = isIPv6\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const toBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  if (isV4(ip)) {\n    const bytes = new Uint8Array(offset + 4)\n\n    ip.split(/\\./g).forEach((byte) => {\n      bytes[offset++] = parseInt(byte, 10) & 0xff\n    })\n\n    return bytes\n  }\n\n  if (isV6(ip)) {\n    const sections = ip.split(':', 8)\n\n    let i\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = isV4(sections[i])\n      let v4Buffer: Uint8Array | undefined\n\n      if (isv4) {\n        v4Buffer = toBytes(sections[i])\n        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')\n      }\n\n      if (v4Buffer != null && ++i < 8) {\n        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0')\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0')\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      const argv: [number, number, ...string[]] = [i, 1]\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0')\n      }\n      sections.splice.apply(sections, argv)\n    }\n\n    const bytes = new Uint8Array(offset + 16)\n\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16)\n      bytes[offset++] = (word >> 8) & 0xff\n      bytes[offset++] = word & 0xff\n    }\n\n    return bytes\n  }\n\n  throw new Error('invalid ip address')\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const toString = function (buf: Uint8Array, offset: number = 0, length?: number): string {\n  offset = ~~offset\n  length = length ?? (buf.length - offset)\n\n  const view = new DataView(buf.buffer)\n\n  if (length === 4) {\n    const result = []\n\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buf[offset + i])\n    }\n\n    return result.join('.')\n  }\n\n  if (length === 16) {\n    const result = []\n\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(view.getUint16(offset + i).toString(16))\n    }\n\n    return result.join(':')\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n\n  return ''\n}\n","import type { Protocol } from './index.js'\n\nconst V = -1\nexport const names: Record<string, Protocol> = {}\nexport const codes: Record<number, Protocol> = {}\n\nexport const table: Array<[number, number, string, boolean?, boolean?]> = [\n  [4, 32, 'ip4'],\n  [6, 16, 'tcp'],\n  [33, 16, 'dccp'],\n  [41, 128, 'ip6'],\n  [42, V, 'ip6zone'],\n  [43, 8, 'ipcidr'],\n  [53, V, 'dns', true],\n  [54, V, 'dns4', true],\n  [55, V, 'dns6', true],\n  [56, V, 'dnsaddr', true],\n  [132, 16, 'sctp'],\n  [273, 16, 'udp'],\n  [275, 0, 'p2p-webrtc-star'],\n  [276, 0, 'p2p-webrtc-direct'],\n  [277, 0, 'p2p-stardust'],\n  [280, 0, 'webrtc-direct'],\n  [281, 0, 'webrtc'],\n  [290, 0, 'p2p-circuit'],\n  [301, 0, 'udt'],\n  [302, 0, 'utp'],\n  [400, V, 'unix', false, true],\n  // `ipfs` is added before `p2p` for legacy support.\n  // All text representations will default to `p2p`, but `ipfs` will\n  // still be supported\n  [421, V, 'ipfs'],\n  // `p2p` is the preferred name for 421, and is now the default\n  [421, V, 'p2p'],\n  [443, 0, 'https'],\n  [444, 96, 'onion'],\n  [445, 296, 'onion3'],\n  [446, V, 'garlic64'],\n  [448, 0, 'tls'],\n  [449, V, 'sni'],\n  [460, 0, 'quic'],\n  [461, 0, 'quic-v1'],\n  [465, 0, 'webtransport'],\n  [466, V, 'certhash'],\n  [477, 0, 'ws'],\n  [478, 0, 'wss'],\n  [479, 0, 'p2p-websocket-star'],\n  [480, 0, 'http'],\n  [481, V, 'http-path'],\n  [777, V, 'memory']\n]\n\n// populate tables\ntable.forEach(row => {\n  const proto = createProtocol(...row)\n  codes[proto.code] = proto\n  names[proto.name] = proto\n})\n\nexport function createProtocol (code: number, size: number, name: string, resolvable?: any, path?: any): Protocol {\n  return {\n    code,\n    size,\n    name,\n    resolvable: Boolean(resolvable),\n    path: Boolean(path)\n  }\n}\n\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol (proto: number | string): Protocol {\n  if (typeof proto === 'number') {\n    if (codes[proto] != null) {\n      return codes[proto]\n    }\n\n    throw new Error(`no protocol with code: ${proto}`)\n  } else if (typeof proto === 'string') {\n    if (names[proto] != null) {\n      return names[proto]\n    }\n\n    throw new Error(`no protocol with name: ${proto}`)\n  }\n\n  throw new Error(`invalid protocol id type: ${typeof proto}`)\n}\n","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\n\nimport { IpNet } from '@chainsafe/netmask'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Multiaddr } from './index.js'\n\nconst ip4Protocol = getProtocol('ip4')\nconst ip6Protocol = getProtocol('ip6')\nconst ipcidrProtocol = getProtocol('ipcidr')\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string): Uint8Array\nexport function convert (proto: string, a: Uint8Array): string\nexport function convert (proto: string, a: string | Uint8Array): Uint8Array | string {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString (proto: number | string, buf: Uint8Array): string {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n    case 42: // ipv6zone\n      return bytes2str(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    case 466: // certhash\n      return bytes2mb(buf)\n    case 481: // http-path\n      return globalThis.encodeURIComponent(bytes2str(buf))\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\nexport function convertToBytes (proto: string | number, str: string): Uint8Array {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n    case 42: // ipv6zone\n      return str2bytes(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    case 466: // certhash\n      return mb2bytes(str)\n    case 481: // http-path\n      return str2bytes(globalThis.decodeURIComponent(str))\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nexport function convertToIpNet (multiaddr: Multiaddr): IpNet {\n  let mask: string | undefined\n  let addr: string | undefined\n  multiaddr.stringTuples().forEach(([code, value]) => {\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value\n    }\n    if (code === ipcidrProtocol.code) {\n      mask = value\n    }\n  })\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr')\n  }\n  return new IpNet(addr, mask)\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nfunction ip2bytes (ipString: string): Uint8Array {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array): string {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null) {\n    throw new Error('ipBuff is required')\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array): number {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string): Uint8Array {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.encodingLength(size))\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string): Uint8Array {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\nfunction mb2bytes (mbstr: string): Uint8Array {\n  const mb = anybaseDecoder.decode(mbstr)\n  const size = Uint8Array.from(varint.encode(mb.length))\n  return uint8ArrayConcat([size, mb], size.length + mb.length)\n}\nfunction bytes2mb (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const hash = buf.slice(varint.encodingLength(size))\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url')\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.encodingLength(size))\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n","import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { convertToBytes, convertToString } from './convert.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { StringTuple, Tuple, Protocol } from './index.js'\n\nexport interface MultiaddrParts {\n  bytes: Uint8Array\n  string: string\n  tuples: Tuple[]\n  stringTuples: StringTuple[]\n  path: string | null\n}\n\nexport function stringToMultiaddrParts (str: string): MultiaddrParts {\n  str = cleanPath(str)\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  const parts = str.split('/').slice(1)\n  if (parts.length === 1 && parts[0] === '') {\n    return {\n      bytes: new Uint8Array(),\n      string: '/',\n      tuples: [],\n      stringTuples: [],\n      path: null\n    }\n  }\n\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p]\n    const proto = getProtocol(part)\n\n    if (proto.size === 0) {\n      tuples.push([proto.code])\n      stringTuples.push([proto.code])\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    p++ // advance addr part\n    if (p >= parts.length) {\n      throw ParseError('invalid address: ' + str)\n    }\n\n    // if it's a path proto, take the rest\n    if (proto.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = cleanPath(parts.slice(p).join('/'))\n      tuples.push([proto.code, convertToBytes(proto.code, path)])\n      stringTuples.push([proto.code, path])\n      break\n    }\n\n    const bytes = convertToBytes(proto.code, parts[p])\n    tuples.push([proto.code, bytes])\n    stringTuples.push([proto.code, convertToString(proto.code, bytes)])\n  }\n\n  return {\n    string: stringTuplesToString(stringTuples),\n    bytes: tuplesToBytes(tuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\nexport function bytesToMultiaddrParts (bytes: Uint8Array): MultiaddrParts {\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, bytes.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      stringTuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = bytes.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > bytes.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(bytes, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n    const stringAddr = convertToString(code, addr)\n    stringTuples.push([code, stringAddr])\n    if (p.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = stringAddr\n      break\n    }\n  }\n\n  return {\n    bytes: Uint8Array.from(bytes),\n    string: stringTuplesToString(stringTuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\n/**\n * [[str name, str addr]... ] -> string\n */\nfunction stringTuplesToString (tuples: StringTuple[]): string {\n  const parts: string[] = []\n  tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    parts.push(proto.name)\n    if (tup.length > 1 && tup[1] != null) {\n      parts.push(tup[1])\n    }\n    return null\n  })\n\n  return cleanPath(parts.join('/'))\n}\n\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nexport function tuplesToBytes (tuples: Tuple[]): Uint8Array {\n  return uint8ArrayConcat(tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    let buf = Uint8Array.from(varint.encode(proto.code))\n\n    if (tup.length > 1 && tup[1] != null) {\n      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer\n    }\n\n    return buf\n  }))\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (p: Protocol, addr: Uint8Array | number[]): number {\n  if (p.size > 0) {\n    return p.size / 8\n  } else if (p.size === 0) {\n    return 0\n  } else {\n    const size = varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr))\n    return size + varint.encodingLength(size)\n  }\n}\n\nexport function bytesToTuples (buf: Uint8Array): Tuple[] {\n  const tuples: Array<[number, Uint8Array?]> = []\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, buf.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = buf.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > buf.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n  }\n\n  return tuples\n}\n\nexport function cleanPath (str: string): string {\n  return '/' + str.trim().split('/').filter((a) => a).join('/')\n}\n\nexport function ParseError (str: string): Error {\n  return new Error('Error parsing address: ' + str)\n}\n","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\n\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, type MultiaddrParts, tuplesToBytes } from './codec.js'\nimport { getProtocol, names } from './protocols-table.js'\nimport { isMultiaddr, multiaddr, resolvers } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, MultiaddrObject, Protocol, StringTuple, Tuple, NodeAddress, ResolveOptions } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')\n\nconst DNS_CODES = [\n  getProtocol('dns').code,\n  getProtocol('dns4').code,\n  getProtocol('dns6').code,\n  getProtocol('dnsaddr').code\n]\n\nclass NoAvailableResolverError extends Error {\n  constructor (message = 'No available resolver') {\n    super(message)\n    this.name = 'NoAvailableResolverError'\n  }\n}\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  public bytes: Uint8Array\n  readonly #string: string\n  readonly #tuples: Tuple[]\n  readonly #stringTuples: StringTuple[]\n  readonly #path: string | null\n\n  [symbol]: boolean = true\n\n  constructor (addr?: MultiaddrInput) {\n    // default\n    if (addr == null) {\n      addr = ''\n    }\n\n    let parts: MultiaddrParts\n    if (addr instanceof Uint8Array) {\n      parts = bytesToMultiaddrParts(addr)\n    } else if (typeof addr === 'string') {\n      if (addr.length > 0 && addr.charAt(0) !== '/') {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      parts = stringToMultiaddrParts(addr)\n    } else if (isMultiaddr(addr)) { // Multiaddr\n      parts = bytesToMultiaddrParts(addr.bytes)\n    } else {\n      throw new Error('addr must be a string, Buffer, or another Multiaddr')\n    }\n\n    this.bytes = parts.bytes\n    this.#string = parts.string\n    this.#tuples = parts.tuples\n    this.#stringTuples = parts.stringTuples\n    this.#path = parts.path\n  }\n\n  toString (): string {\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  toOptions (): MultiaddrObject {\n    let family: 4 | 6 | undefined\n    let transport: string | undefined\n    let host: string | undefined\n    let port: number | undefined\n    let zone = ''\n\n    const tcp = getProtocol('tcp')\n    const udp = getProtocol('udp')\n    const ip4 = getProtocol('ip4')\n    const ip6 = getProtocol('ip6')\n    const dns6 = getProtocol('dns6')\n    const ip6zone = getProtocol('ip6zone')\n\n    for (const [code, value] of this.stringTuples()) {\n      if (code === ip6zone.code) {\n        zone = `%${value ?? ''}`\n      }\n\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = tcp.name\n        port = 443\n        host = `${value ?? ''}${zone}`\n        family = code === dns6.code ? 6 : 4\n      }\n\n      if (code === tcp.code || code === udp.code) {\n        transport = getProtocol(code).name\n        port = parseInt(value ?? '')\n      }\n\n      if (code === ip4.code || code === ip6.code) {\n        transport = getProtocol(code).name\n        host = `${value ?? ''}${zone}`\n        family = code === ip6.code ? 6 : 4\n      }\n    }\n\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".')\n    }\n\n    const opts: MultiaddrObject = {\n      family,\n      host,\n      transport,\n      port\n    }\n\n    return opts\n  }\n\n  protos (): Protocol[] {\n    return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)))\n  }\n\n  protoCodes (): number[] {\n    return this.#tuples.map(([code]) => code)\n  }\n\n  protoNames (): string[] {\n    return this.#tuples.map(([code]) => getProtocol(code).name)\n  }\n\n  tuples (): Array<[number, Uint8Array?]> {\n    return this.#tuples\n  }\n\n  stringTuples (): Array<[number, string?]> {\n    return this.#stringTuples\n  }\n\n  encapsulate (addr: MultiaddrInput): Multiaddr {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  decapsulate (addr: Multiaddr | string): Multiaddr {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n    if (i < 0) {\n      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`)\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(tuplesToBytes(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  getPeerId (): string | null {\n    try {\n      let tuples: Array<[number, string | undefined]> = []\n\n      this.stringTuples().forEach(([code, name]) => {\n        if (code === names.p2p.code) {\n          tuples.push([code, name])\n        }\n\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === names['p2p-circuit'].code) {\n          tuples = []\n        }\n      })\n\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  getPath (): string | null {\n    return this.#path\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  async resolve (options?: ResolveOptions): Promise<MultiaddrInterface[]> {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (resolver == null) {\n      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`)\n    }\n\n    const result = await resolver(this, options)\n\n    return result.map(str => multiaddr(str))\n  }\n\n  nodeAddress (): NodeAddress {\n    const options = this.toOptions()\n\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`)\n    }\n\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    }\n  }\n\n  isThinWaistAddress (addr?: Multiaddr): boolean {\n    const protos = (addr ?? this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    if (protos[1].code !== 6 && protos[1].code !== 273) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.#string})`\n  }\n}\n","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n","/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * const addr =  multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * const addr = multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddr } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddr)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(await ma.resolve(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n */\n\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Resolver } from './resolvers/index.js'\nimport type { DNS } from '@multiformats/dns'\n\n/**\n * Protocols are present in the protocol table\n */\nexport interface Protocol {\n  code: number\n  size: number\n  name: string\n  resolvable?: boolean | undefined\n  path?: boolean | undefined\n}\n\n/**\n * A plain JavaScript object representation of a {@link Multiaddr}\n */\nexport interface MultiaddrObject {\n  family: 4 | 6\n  host: string\n  transport: string\n  port: number\n}\n\n/**\n * A NodeAddress is an IPv4/IPv6 address/TCP port combination\n */\nexport interface NodeAddress {\n  family: 4 | 6\n  address: string\n  port: number\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null\n\n/**\n * A code/value pair\n */\nexport type Tuple = [number, Uint8Array?]\n\n/**\n * A code/value pair with the value as a string\n */\nexport type StringTuple = [number, string?]\n\n/**\n * Allows aborting long-lived operations\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map<string, Resolver>()\n\nexport type { Resolver }\n\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js'\n\nexport interface ResolveOptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns Multiaddr as a convinient options object to be used with net.createConnection\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   * ```\n   */\n  toOptions(): MultiaddrObject\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   * ```\n   */\n  protos(): Protocol[]\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   * ```\n   */\n  protoCodes(): number[]\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   * ```\n   */\n  protoNames(): string[]\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   * ```\n   */\n  tuples(): Tuple[]\n\n  /**\n   * Returns a tuple of string/number parts\n   * - tuples[][0] = code of protocol\n   * - tuples[][1] = contents of address\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]\n   * ```\n   */\n  stringTuples(): StringTuple[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string)\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   * ```\n   */\n  getPeerId(): string | null\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock)\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   * ```\n   */\n  getPath(): string | null\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n\n  /**\n   * Resolve multiaddr if containing resolvable hostname.\n   *\n   * @example\n   * ```js\n   * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n   *\n   * resolvers.set('dnsaddr', resolverFunction)\n   * const mh1 = multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n   * const resolvedMultiaddrs = await mh1.resolve()\n   * // [\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb)\n   * // ]\n   * ```\n   */\n  resolve(options?: ResolveOptions): Promise<Multiaddr[]>\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 4, address: '127.0.0.1', port: 4001}\n   * ```\n   */\n  nodeAddress(): NodeAddress\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   * const mh2 = multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // Multiaddr(/ip4/192.168.2.1/tcp/5001)\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001)\n   * const mh4 = multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a)\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   * mh4.isThinWaistAddress()\n   * // false\n   * ```\n   */\n  isThinWaistAddress(addr?: Multiaddr): boolean\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress (addr: NodeAddress, transport: string): Multiaddr {\n  if (addr == null) {\n    throw new Error('requires node address object')\n  }\n  if (transport == null) {\n    throw new Error('requires transport protocol')\n  }\n  let ip: string | undefined\n  let host = addr.address\n  switch (addr.family) {\n    case 4:\n      ip = 'ip4'\n      break\n    case 6:\n      ip = 'ip6'\n\n      if (host.includes('%')) {\n        const parts = host.split('%')\n\n        if (parts.length !== 2) {\n          throw Error('Multiple ip6 zones in multiaddr')\n        }\n\n        host = parts[0]\n        const zone = parts[1]\n        ip = `/ip6zone/${zone}/ip6`\n      }\n      break\n    default:\n      throw Error('Invalid addr family, should be 4 or 6.')\n  }\n  return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'))\n}\n\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName (addr: Multiaddr): boolean {\n  if (!isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\nexport { getProtocol as protocols }\n","import { multiaddr } from '@multiformats/multiaddr'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface MatchesFunction { (a: string | Uint8Array | Multiaddr): boolean }\nexport interface PartialMatchesFunction { (protos: string[]): boolean | string[] | null }\n\nexport interface Mafmt {\n  toString: () => string\n  input?: Array<(Mafmt | (() => Mafmt))>\n  matches: MatchesFunction\n  partialMatch: PartialMatchesFunction\n}\n\n/*\n * Valid combinations\n */\nexport const DNS4 = base('dns4')\nexport const DNS6 = base('dns6')\nexport const DNSADDR = base('dnsaddr')\nexport const DNS = or(\n  base('dns'),\n  DNSADDR,\n  DNS4,\n  DNS6\n)\n\nexport const IP = or(base('ip4'), base('ip6'))\nexport const TCP = or(\n  and(IP, base('tcp')),\n  and(DNS, base('tcp'))\n)\nexport const UDP = and(IP, base('udp'))\nexport const UTP = and(UDP, base('utp'))\n\nexport const QUIC = and(UDP, base('quic'))\nexport const QUICV1 = and(UDP, base('quic-v1'))\n\nconst _WebSockets = or(\n  and(TCP, base('ws')),\n  and(DNS, base('ws'))\n)\n\nexport const WebSockets = or(\n  and(_WebSockets, base('p2p')),\n  _WebSockets\n)\n\nconst _WebSocketsSecure = or(\n  and(TCP, base('wss')),\n  and(DNS, base('wss')),\n  and(TCP, base('tls'), base('ws')),\n  and(DNS, base('tls'), base('ws'))\n)\n\nexport const WebSocketsSecure = or(\n  and(_WebSocketsSecure, base('p2p')),\n  _WebSocketsSecure\n)\n\nexport const HTTP = or(\n  and(TCP, base('http')),\n  and(IP, base('http')),\n  and(DNS, base('http'))\n)\n\nexport const HTTPS = or(\n  and(TCP, base('https')),\n  and(IP, base('https')),\n  and(DNS, base('https'))\n)\n\nconst _WebRTCDirect = and(UDP, base('webrtc-direct'), base('certhash'))\nexport const WebRTCDirect = or(\n  and(_WebRTCDirect, base('p2p')),\n  _WebRTCDirect\n)\n\nconst _WebTransport = and(QUICV1, base('webtransport'), base('certhash'), base('certhash'))\nexport const WebTransport = or(\n  and(_WebTransport, base('p2p')),\n  _WebTransport\n)\n\n/**\n * @deprecated\n */\nexport const P2PWebRTCStar = or(\n  and(WebSockets, base('p2p-webrtc-star'), base('p2p')),\n  and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')),\n  and(WebSockets, base('p2p-webrtc-star')),\n  and(WebSocketsSecure, base('p2p-webrtc-star'))\n)\n\nexport const WebSocketStar = or(\n  and(WebSockets, base('p2p-websocket-star'), base('p2p')),\n  and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')),\n  and(WebSockets, base('p2p-websocket-star')),\n  and(WebSocketsSecure, base('p2p-websocket-star'))\n)\n\n/**\n * @deprecated\n */\nexport const P2PWebRTCDirect = or(\n  and(HTTP, base('p2p-webrtc-direct'), base('p2p')),\n  and(HTTPS, base('p2p-webrtc-direct'), base('p2p')),\n  and(HTTP, base('p2p-webrtc-direct')),\n  and(HTTPS, base('p2p-webrtc-direct'))\n)\n\nexport const Reliable = or(\n  _WebSockets,\n  _WebSocketsSecure,\n  HTTP,\n  HTTPS,\n  P2PWebRTCStar,\n  P2PWebRTCDirect,\n  TCP,\n  UTP,\n  QUIC,\n  DNS,\n  WebRTCDirect,\n  WebTransport\n)\n\n// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\nexport const Stardust = or(\n  and(Reliable, base('p2p-stardust'), base('p2p')),\n  and(Reliable, base('p2p-stardust'))\n)\n\nconst _P2P = or(\n  and(Reliable, base('p2p')),\n  P2PWebRTCStar,\n  P2PWebRTCDirect,\n  WebRTCDirect,\n  WebTransport,\n  base('p2p')\n)\n\nconst _Circuit = or(\n  and(_P2P, base('p2p-circuit'), _P2P),\n  and(_P2P, base('p2p-circuit')),\n  and(base('p2p-circuit'), _P2P),\n  and(Reliable, base('p2p-circuit')),\n  and(base('p2p-circuit'), Reliable),\n  base('p2p-circuit')\n)\n\nconst CircuitRecursive = (): Mafmt => or(\n  and(_Circuit, CircuitRecursive),\n  _Circuit\n)\n\nexport const Circuit = CircuitRecursive()\n\nexport const P2P = or(\n  and(Circuit, _P2P, Circuit),\n  and(_P2P, Circuit),\n  and(Circuit, _P2P),\n  Circuit,\n  _P2P\n)\n\nexport const IPFS = P2P\n\nexport const WebRTC = or(\n  and(Circuit, base('webrtc'), base('p2p')),\n  and(Circuit, base('webrtc')),\n  and(Reliable, base('webrtc'), base('p2p')),\n  and(Reliable, base('webrtc')),\n  base('webrtc')\n)\n\n/*\n * Validation funcs\n */\n\nfunction makeMatchesFunction (partialMatch: PartialMatchesFunction): (a: string | Uint8Array | Multiaddr) => boolean {\n  function matches (a: string | Uint8Array | Multiaddr): boolean {\n    let ma\n\n    try {\n      ma = multiaddr(a)\n    } catch (err: any) { // catch error\n      return false // also if it's invalid it's probably not matching as well so return false\n    }\n\n    const out = partialMatch(ma.protoNames())\n    if (out === null) {\n      return false\n    }\n\n    if (out === true || out === false) {\n      return out\n    }\n\n    return out.length === 0\n  }\n\n  return matches\n}\n\nfunction and (...args: Array<Mafmt | (() => Mafmt)>): Mafmt {\n  function partialMatch (a: string[]): boolean | string[] | null {\n    if (a.length < args.length) {\n      return null\n    }\n\n    let out: boolean | string[] | null = a\n\n    args.some((arg) => {\n      out = typeof arg === 'function'\n        ? arg().partialMatch(a)\n        : arg.partialMatch(a)\n\n      if (Array.isArray(out)) {\n        a = out\n      }\n\n      if (out === null) {\n        return true\n      }\n\n      return false\n    })\n\n    return out\n  }\n\n  return {\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch\n  }\n}\n\nfunction or (...args: Array<Mafmt | (() => Mafmt)>): Mafmt {\n  function partialMatch (a: string[]): boolean | string[] | null {\n    let out = null\n    args.some((arg) => {\n      const res = typeof arg === 'function'\n        ? arg().partialMatch(a)\n        : arg.partialMatch(a)\n      if (res != null) {\n        out = res\n        return true\n      }\n      return false\n    })\n\n    return out\n  }\n\n  const result = {\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch\n  }\n\n  return result\n}\n\nfunction base (n: string): Mafmt {\n  const name = n\n\n  function matches (a: string | Uint8Array | Multiaddr): boolean {\n    let ma: Multiaddr\n\n    try {\n      ma = multiaddr(a)\n    } catch (err: any) { // catch error\n      return false // also if it's invalid it's probably not matching as well so return false\n    }\n\n    const pnames = ma.protoNames()\n    if (pnames.length === 1 && pnames[0] === name) {\n      return true\n    }\n    return false\n  }\n\n  function partialMatch (protos: string[]): boolean | string[] | null {\n    if (protos.length === 0) {\n      return null\n    }\n\n    if (protos[0] === name) {\n      return protos.slice(1)\n    }\n    return null\n  }\n\n  return {\n    toString: function () { return name },\n    matches,\n    partialMatch\n  }\n}\n","export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabet: string, bitsPerChar: number, name: string): Uint8Array {\n  // Build the character lookup table:\n  const codes: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n","import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n","import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n","import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n","import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n","import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n","import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n","import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array): Digest.Digest<typeof code, number> {\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n","import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n","import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n","import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString (array: Uint8Array, encoding: SupportedEncodings = 'utf8'): string {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // strip multibase prefix\n  return base.encoder.encode(array).substring(1)\n}\n","import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n","import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n","import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport { isIP } from '@chainsafe/is-ip'\nexport const isV4 = isIPv4\nexport const isV6 = isIPv6\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const toBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  if (isV4(ip)) {\n    const bytes = new Uint8Array(offset + 4)\n\n    ip.split(/\\./g).forEach((byte) => {\n      bytes[offset++] = parseInt(byte, 10) & 0xff\n    })\n\n    return bytes\n  }\n\n  if (isV6(ip)) {\n    const sections = ip.split(':', 8)\n\n    let i\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = isV4(sections[i])\n      let v4Buffer: Uint8Array | undefined\n\n      if (isv4) {\n        v4Buffer = toBytes(sections[i])\n        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')\n      }\n\n      if (v4Buffer != null && ++i < 8) {\n        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0')\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0')\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      const argv: [number, number, ...string[]] = [i, 1]\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0')\n      }\n      sections.splice.apply(sections, argv)\n    }\n\n    const bytes = new Uint8Array(offset + 16)\n\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16)\n      bytes[offset++] = (word >> 8) & 0xff\n      bytes[offset++] = word & 0xff\n    }\n\n    return bytes\n  }\n\n  throw new Error('invalid ip address')\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const toString = function (buf: Uint8Array, offset: number = 0, length?: number): string {\n  offset = ~~offset\n  length = length ?? (buf.length - offset)\n\n  const view = new DataView(buf.buffer)\n\n  if (length === 4) {\n    const result = []\n\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buf[offset + i])\n    }\n\n    return result.join('.')\n  }\n\n  if (length === 16) {\n    const result = []\n\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(view.getUint16(offset + i).toString(16))\n    }\n\n    return result.join(':')\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n\n  return ''\n}\n","import type { Protocol } from './index.js'\n\nconst V = -1\nexport const names: Record<string, Protocol> = {}\nexport const codes: Record<number, Protocol> = {}\n\nexport const table: Array<[number, number, string, boolean?, boolean?]> = [\n  [4, 32, 'ip4'],\n  [6, 16, 'tcp'],\n  [33, 16, 'dccp'],\n  [41, 128, 'ip6'],\n  [42, V, 'ip6zone'],\n  [43, 8, 'ipcidr'],\n  [53, V, 'dns', true],\n  [54, V, 'dns4', true],\n  [55, V, 'dns6', true],\n  [56, V, 'dnsaddr', true],\n  [132, 16, 'sctp'],\n  [273, 16, 'udp'],\n  [275, 0, 'p2p-webrtc-star'],\n  [276, 0, 'p2p-webrtc-direct'],\n  [277, 0, 'p2p-stardust'],\n  [280, 0, 'webrtc-direct'],\n  [281, 0, 'webrtc'],\n  [290, 0, 'p2p-circuit'],\n  [301, 0, 'udt'],\n  [302, 0, 'utp'],\n  [400, V, 'unix', false, true],\n  // `ipfs` is added before `p2p` for legacy support.\n  // All text representations will default to `p2p`, but `ipfs` will\n  // still be supported\n  [421, V, 'ipfs'],\n  // `p2p` is the preferred name for 421, and is now the default\n  [421, V, 'p2p'],\n  [443, 0, 'https'],\n  [444, 96, 'onion'],\n  [445, 296, 'onion3'],\n  [446, V, 'garlic64'],\n  [448, 0, 'tls'],\n  [449, V, 'sni'],\n  [460, 0, 'quic'],\n  [461, 0, 'quic-v1'],\n  [465, 0, 'webtransport'],\n  [466, V, 'certhash'],\n  [477, 0, 'ws'],\n  [478, 0, 'wss'],\n  [479, 0, 'p2p-websocket-star'],\n  [480, 0, 'http'],\n  [481, V, 'http-path'],\n  [777, V, 'memory']\n]\n\n// populate tables\ntable.forEach(row => {\n  const proto = createProtocol(...row)\n  codes[proto.code] = proto\n  names[proto.name] = proto\n})\n\nexport function createProtocol (code: number, size: number, name: string, resolvable?: any, path?: any): Protocol {\n  return {\n    code,\n    size,\n    name,\n    resolvable: Boolean(resolvable),\n    path: Boolean(path)\n  }\n}\n\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol (proto: number | string): Protocol {\n  if (typeof proto === 'number') {\n    if (codes[proto] != null) {\n      return codes[proto]\n    }\n\n    throw new Error(`no protocol with code: ${proto}`)\n  } else if (typeof proto === 'string') {\n    if (names[proto] != null) {\n      return names[proto]\n    }\n\n    throw new Error(`no protocol with name: ${proto}`)\n  }\n\n  throw new Error(`invalid protocol id type: ${typeof proto}`)\n}\n","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\n\nimport { IpNet } from '@chainsafe/netmask'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Multiaddr } from './index.js'\n\nconst ip4Protocol = getProtocol('ip4')\nconst ip6Protocol = getProtocol('ip6')\nconst ipcidrProtocol = getProtocol('ipcidr')\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string): Uint8Array\nexport function convert (proto: string, a: Uint8Array): string\nexport function convert (proto: string, a: string | Uint8Array): Uint8Array | string {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString (proto: number | string, buf: Uint8Array): string {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n    case 42: // ipv6zone\n      return bytes2str(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    case 466: // certhash\n      return bytes2mb(buf)\n    case 481: // http-path\n      return globalThis.encodeURIComponent(bytes2str(buf))\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\nexport function convertToBytes (proto: string | number, str: string): Uint8Array {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n    case 42: // ipv6zone\n      return str2bytes(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    case 466: // certhash\n      return mb2bytes(str)\n    case 481: // http-path\n      return str2bytes(globalThis.decodeURIComponent(str))\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nexport function convertToIpNet (multiaddr: Multiaddr): IpNet {\n  let mask: string | undefined\n  let addr: string | undefined\n  multiaddr.stringTuples().forEach(([code, value]) => {\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value\n    }\n    if (code === ipcidrProtocol.code) {\n      mask = value\n    }\n  })\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr')\n  }\n  return new IpNet(addr, mask)\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nfunction ip2bytes (ipString: string): Uint8Array {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array): string {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null) {\n    throw new Error('ipBuff is required')\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array): number {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string): Uint8Array {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.encodingLength(size))\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string): Uint8Array {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\nfunction mb2bytes (mbstr: string): Uint8Array {\n  const mb = anybaseDecoder.decode(mbstr)\n  const size = Uint8Array.from(varint.encode(mb.length))\n  return uint8ArrayConcat([size, mb], size.length + mb.length)\n}\nfunction bytes2mb (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const hash = buf.slice(varint.encodingLength(size))\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url')\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.encodingLength(size))\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n","import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { convertToBytes, convertToString } from './convert.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { StringTuple, Tuple, Protocol } from './index.js'\n\nexport interface MultiaddrParts {\n  bytes: Uint8Array\n  string: string\n  tuples: Tuple[]\n  stringTuples: StringTuple[]\n  path: string | null\n}\n\nexport function stringToMultiaddrParts (str: string): MultiaddrParts {\n  str = cleanPath(str)\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  const parts = str.split('/').slice(1)\n  if (parts.length === 1 && parts[0] === '') {\n    return {\n      bytes: new Uint8Array(),\n      string: '/',\n      tuples: [],\n      stringTuples: [],\n      path: null\n    }\n  }\n\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p]\n    const proto = getProtocol(part)\n\n    if (proto.size === 0) {\n      tuples.push([proto.code])\n      stringTuples.push([proto.code])\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    p++ // advance addr part\n    if (p >= parts.length) {\n      throw ParseError('invalid address: ' + str)\n    }\n\n    // if it's a path proto, take the rest\n    if (proto.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = cleanPath(parts.slice(p).join('/'))\n      tuples.push([proto.code, convertToBytes(proto.code, path)])\n      stringTuples.push([proto.code, path])\n      break\n    }\n\n    const bytes = convertToBytes(proto.code, parts[p])\n    tuples.push([proto.code, bytes])\n    stringTuples.push([proto.code, convertToString(proto.code, bytes)])\n  }\n\n  return {\n    string: stringTuplesToString(stringTuples),\n    bytes: tuplesToBytes(tuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\nexport function bytesToMultiaddrParts (bytes: Uint8Array): MultiaddrParts {\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, bytes.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      stringTuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = bytes.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > bytes.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(bytes, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n    const stringAddr = convertToString(code, addr)\n    stringTuples.push([code, stringAddr])\n    if (p.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = stringAddr\n      break\n    }\n  }\n\n  return {\n    bytes: Uint8Array.from(bytes),\n    string: stringTuplesToString(stringTuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\n/**\n * [[str name, str addr]... ] -> string\n */\nfunction stringTuplesToString (tuples: StringTuple[]): string {\n  const parts: string[] = []\n  tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    parts.push(proto.name)\n    if (tup.length > 1 && tup[1] != null) {\n      parts.push(tup[1])\n    }\n    return null\n  })\n\n  return cleanPath(parts.join('/'))\n}\n\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nexport function tuplesToBytes (tuples: Tuple[]): Uint8Array {\n  return uint8ArrayConcat(tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    let buf = Uint8Array.from(varint.encode(proto.code))\n\n    if (tup.length > 1 && tup[1] != null) {\n      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer\n    }\n\n    return buf\n  }))\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (p: Protocol, addr: Uint8Array | number[]): number {\n  if (p.size > 0) {\n    return p.size / 8\n  } else if (p.size === 0) {\n    return 0\n  } else {\n    const size = varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr))\n    return size + varint.encodingLength(size)\n  }\n}\n\nexport function bytesToTuples (buf: Uint8Array): Tuple[] {\n  const tuples: Array<[number, Uint8Array?]> = []\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, buf.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = buf.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > buf.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n  }\n\n  return tuples\n}\n\nexport function cleanPath (str: string): string {\n  return '/' + str.trim().split('/').filter((a) => a).join('/')\n}\n\nexport function ParseError (str: string): Error {\n  return new Error('Error parsing address: ' + str)\n}\n","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\n\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, type MultiaddrParts, tuplesToBytes } from './codec.js'\nimport { getProtocol, names } from './protocols-table.js'\nimport { isMultiaddr, multiaddr, resolvers } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, MultiaddrObject, Protocol, StringTuple, Tuple, NodeAddress, ResolveOptions } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')\n\nconst DNS_CODES = [\n  getProtocol('dns').code,\n  getProtocol('dns4').code,\n  getProtocol('dns6').code,\n  getProtocol('dnsaddr').code\n]\n\nclass NoAvailableResolverError extends Error {\n  constructor (message = 'No available resolver') {\n    super(message)\n    this.name = 'NoAvailableResolverError'\n  }\n}\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  public bytes: Uint8Array\n  readonly #string: string\n  readonly #tuples: Tuple[]\n  readonly #stringTuples: StringTuple[]\n  readonly #path: string | null\n\n  [symbol]: boolean = true\n\n  constructor (addr?: MultiaddrInput) {\n    // default\n    if (addr == null) {\n      addr = ''\n    }\n\n    let parts: MultiaddrParts\n    if (addr instanceof Uint8Array) {\n      parts = bytesToMultiaddrParts(addr)\n    } else if (typeof addr === 'string') {\n      if (addr.length > 0 && addr.charAt(0) !== '/') {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      parts = stringToMultiaddrParts(addr)\n    } else if (isMultiaddr(addr)) { // Multiaddr\n      parts = bytesToMultiaddrParts(addr.bytes)\n    } else {\n      throw new Error('addr must be a string, Buffer, or another Multiaddr')\n    }\n\n    this.bytes = parts.bytes\n    this.#string = parts.string\n    this.#tuples = parts.tuples\n    this.#stringTuples = parts.stringTuples\n    this.#path = parts.path\n  }\n\n  toString (): string {\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  toOptions (): MultiaddrObject {\n    let family: 4 | 6 | undefined\n    let transport: string | undefined\n    let host: string | undefined\n    let port: number | undefined\n    let zone = ''\n\n    const tcp = getProtocol('tcp')\n    const udp = getProtocol('udp')\n    const ip4 = getProtocol('ip4')\n    const ip6 = getProtocol('ip6')\n    const dns6 = getProtocol('dns6')\n    const ip6zone = getProtocol('ip6zone')\n\n    for (const [code, value] of this.stringTuples()) {\n      if (code === ip6zone.code) {\n        zone = `%${value ?? ''}`\n      }\n\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = tcp.name\n        port = 443\n        host = `${value ?? ''}${zone}`\n        family = code === dns6.code ? 6 : 4\n      }\n\n      if (code === tcp.code || code === udp.code) {\n        transport = getProtocol(code).name\n        port = parseInt(value ?? '')\n      }\n\n      if (code === ip4.code || code === ip6.code) {\n        transport = getProtocol(code).name\n        host = `${value ?? ''}${zone}`\n        family = code === ip6.code ? 6 : 4\n      }\n    }\n\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".')\n    }\n\n    const opts: MultiaddrObject = {\n      family,\n      host,\n      transport,\n      port\n    }\n\n    return opts\n  }\n\n  protos (): Protocol[] {\n    return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)))\n  }\n\n  protoCodes (): number[] {\n    return this.#tuples.map(([code]) => code)\n  }\n\n  protoNames (): string[] {\n    return this.#tuples.map(([code]) => getProtocol(code).name)\n  }\n\n  tuples (): Array<[number, Uint8Array?]> {\n    return this.#tuples\n  }\n\n  stringTuples (): Array<[number, string?]> {\n    return this.#stringTuples\n  }\n\n  encapsulate (addr: MultiaddrInput): Multiaddr {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  decapsulate (addr: Multiaddr | string): Multiaddr {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n    if (i < 0) {\n      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`)\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(tuplesToBytes(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  getPeerId (): string | null {\n    try {\n      let tuples: Array<[number, string | undefined]> = []\n\n      this.stringTuples().forEach(([code, name]) => {\n        if (code === names.p2p.code) {\n          tuples.push([code, name])\n        }\n\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === names['p2p-circuit'].code) {\n          tuples = []\n        }\n      })\n\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  getPath (): string | null {\n    return this.#path\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  async resolve (options?: ResolveOptions): Promise<MultiaddrInterface[]> {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (resolver == null) {\n      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`)\n    }\n\n    const result = await resolver(this, options)\n\n    return result.map(str => multiaddr(str))\n  }\n\n  nodeAddress (): NodeAddress {\n    const options = this.toOptions()\n\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`)\n    }\n\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    }\n  }\n\n  isThinWaistAddress (addr?: Multiaddr): boolean {\n    const protos = (addr ?? this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    if (protos[1].code !== 6 && protos[1].code !== 273) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.#string})`\n  }\n}\n","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n","/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * const addr =  multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * const addr = multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddr } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddr)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(await ma.resolve(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n */\n\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Resolver } from './resolvers/index.js'\nimport type { DNS } from '@multiformats/dns'\n\n/**\n * Protocols are present in the protocol table\n */\nexport interface Protocol {\n  code: number\n  size: number\n  name: string\n  resolvable?: boolean | undefined\n  path?: boolean | undefined\n}\n\n/**\n * A plain JavaScript object representation of a {@link Multiaddr}\n */\nexport interface MultiaddrObject {\n  family: 4 | 6\n  host: string\n  transport: string\n  port: number\n}\n\n/**\n * A NodeAddress is an IPv4/IPv6 address/TCP port combination\n */\nexport interface NodeAddress {\n  family: 4 | 6\n  address: string\n  port: number\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null\n\n/**\n * A code/value pair\n */\nexport type Tuple = [number, Uint8Array?]\n\n/**\n * A code/value pair with the value as a string\n */\nexport type StringTuple = [number, string?]\n\n/**\n * Allows aborting long-lived operations\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map<string, Resolver>()\n\nexport type { Resolver }\n\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js'\n\nexport interface ResolveOptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns Multiaddr as a convinient options object to be used with net.createConnection\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   * ```\n   */\n  toOptions(): MultiaddrObject\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   * ```\n   */\n  protos(): Protocol[]\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   * ```\n   */\n  protoCodes(): number[]\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   * ```\n   */\n  protoNames(): string[]\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   * ```\n   */\n  tuples(): Tuple[]\n\n  /**\n   * Returns a tuple of string/number parts\n   * - tuples[][0] = code of protocol\n   * - tuples[][1] = contents of address\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]\n   * ```\n   */\n  stringTuples(): StringTuple[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string)\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   * ```\n   */\n  getPeerId(): string | null\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock)\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   * ```\n   */\n  getPath(): string | null\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n\n  /**\n   * Resolve multiaddr if containing resolvable hostname.\n   *\n   * @example\n   * ```js\n   * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n   *\n   * resolvers.set('dnsaddr', resolverFunction)\n   * const mh1 = multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n   * const resolvedMultiaddrs = await mh1.resolve()\n   * // [\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb)\n   * // ]\n   * ```\n   */\n  resolve(options?: ResolveOptions): Promise<Multiaddr[]>\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 4, address: '127.0.0.1', port: 4001}\n   * ```\n   */\n  nodeAddress(): NodeAddress\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   * const mh2 = multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // Multiaddr(/ip4/192.168.2.1/tcp/5001)\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001)\n   * const mh4 = multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a)\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   * mh4.isThinWaistAddress()\n   * // false\n   * ```\n   */\n  isThinWaistAddress(addr?: Multiaddr): boolean\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress (addr: NodeAddress, transport: string): Multiaddr {\n  if (addr == null) {\n    throw new Error('requires node address object')\n  }\n  if (transport == null) {\n    throw new Error('requires transport protocol')\n  }\n  let ip: string | undefined\n  let host = addr.address\n  switch (addr.family) {\n    case 4:\n      ip = 'ip4'\n      break\n    case 6:\n      ip = 'ip6'\n\n      if (host.includes('%')) {\n        const parts = host.split('%')\n\n        if (parts.length !== 2) {\n          throw Error('Multiple ip6 zones in multiaddr')\n        }\n\n        host = parts[0]\n        const zone = parts[1]\n        ip = `/ip6zone/${zone}/ip6`\n      }\n      break\n    default:\n      throw Error('Invalid addr family, should be 4 or 6.')\n  }\n  return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'))\n}\n\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName (addr: Multiaddr): boolean {\n  if (!isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\nexport { getProtocol as protocols }\n","/**\n * @packageDocumentation\n *\n * A suite of util methods that provides efficient validation.\n *\n * Detection of IPFS Paths and identifiers in URLs is a two-stage process:\n *\n * 1. `pathPattern`/`pathGatewayPattern`/`subdomainGatewayPattern` regex is applied to quickly identify potential candidates\n * 2. proper CID validation is applied to remove false-positives\n *\n * @example\n *\n * ```TypeScript\n * import * as isIPFS from 'is-ipfs'\n *\n * isIPFS.multihash('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.multihash('noop') // false\n *\n * isIPFS.cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true (CIDv0)\n * isIPFS.cid('bafybeiasb5vpmaounyilfuxbd3lryvosl4yefqrfahsb2esg46q6tu6y5q') // true (CIDv1 in Base32)\n * isIPFS.cid('zdj7WWeQ43G6JJvLWQWZpyHuAMq6uYWRjkBXFad11vE2LHhQ7') // true (CIDv1 in Base58btc)\n * isIPFS.cid('noop') // false\n *\n * isIPFS.base32cid('bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va') // true\n * isIPFS.base32cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n *\n * isIPFS.url('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.url('https://ipfs.io/ipfs/QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR?filename=guardian.jpg') // true\n * isIPFS.url('https://ipfs.io/ipns/github.com') // true\n * isIPFS.url('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.url('http://en.wikipedia-on-ipfs.org.ipfs.localhost:8080') // true\n * isIPFS.url('https://github.com/ipfs/js-ipfs/blob/master/README.md') // false\n * isIPFS.url('https://google.com') // false\n *\n * isIPFS.path('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.path('/ipfs/QmbcBPAwCDxRMB1Qe7CRQmxdrTSkxKwM9y6rZw2FjGtbsb/?weird-filename=test.jpg') // true\n * isIPFS.path('/ipns/github.com') // true\n * isIPFS.path('/ipfs/js-ipfs/blob/master/README.md') // false\n *\n * isIPFS.urlOrPath('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('https://ipfs.io/ipns/github.com') // true\n * isIPFS.urlOrPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('/ipns/github.com') // true\n * isIPFS.urlOrPath('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.urlOrPath('https://google.com') // false\n *\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsUrl('https://ipfs.io/ipns/github.com') // true\n *\n * isIPFS.ipfsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsPath('/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsPath('/ipns/github.com') // true\n *\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/path/to/file') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/file') // false\n *\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.subdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.subdomain('http://www.bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // false\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://QmcNioXSC1bfJj1dcFErhUfyjFzoX2HodkRccsFFVJJvg8.ipns.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://en.wikipedia-on-ipfs.org.ipns.localhost:8080') // true (assuming DNSLink)\n * isIPFS.ipnsSubdomain('http://en-wikipedia--on--ipfs-org.ipns.localhost:8080') // true (assuming inlined DNSLink)\n * isIPFS.ipnsSubdomain('http://hostname-without-tld-.ipns.dweb.link') // false (not a CID, invalid DNS label)\n *\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234') // true\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234/http') // true\n * isIPFS.multiaddr('/ip6/::1/udp/1234') // true\n * isIPFS.multiaddr('ip6/::1/udp/1234') // false\n * isIPFS.multiaddr('/yoloinvalid/::1/udp/1234') // false\n *\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true\n * isIPFS.peerMultiaddr('/ipfs/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true (legacy notation)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/tcp/1234/ws/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4/p2p-circuit/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io') // false (key missing, needs additional DNS lookup to tell if this is valid)\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN') // true (key present, ip and port can be resolved later)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/udp/1234') // false (key missing)\n * ```\n */\n\nimport * as mafmt from '@multiformats/mafmt'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { URL } from 'iso-url'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\nfunction isMultihash (hash: Uint8Array | string): boolean {\n  const formatted = convertToString(hash)\n\n  if (formatted === false) {\n    return false\n  }\n\n  try {\n    Digest.decode(base58btc.decode(`z${formatted}`))\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isMultiaddr (input: string | Uint8Array | Multiaddr): input is Multiaddr {\n  try {\n    return Boolean(multiaddr(input))\n  } catch {\n    return false\n  }\n}\n\nfunction isBase32EncodedMultibase (hash: CID | string | Uint8Array): boolean {\n  try {\n    let cid: CID | null\n\n    if (isString(hash)) {\n      cid = CID.parse(hash)\n    } else {\n      cid = CID.asCID(hash)\n    }\n\n    if (cid == null) {\n      return false\n    }\n\n    base32.decode(cid.toString())\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isCID (hash: CID | Uint8Array | string): hash is CID {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash))\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash))\n    }\n\n    return Boolean(CID.asCID(hash)) // eslint-disable-line no-new\n  } catch {\n    return false\n  }\n}\n\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr (input: string | Uint8Array | Multiaddr): boolean {\n  return isMultiaddr(input) && mafmt.P2P.matches(input)\n}\n\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath): boolean {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath): boolean {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org → en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-')\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {any} input\n */\nfunction isString (input: any): input is string {\n  return typeof input === 'string'\n}\n\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString (input: Uint8Array | string): string | false {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc')\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS subdomain\n * (case-insensitive CIDv1) or `false` otherwise.\n */\nexport const ipfsSubdomain = (url: string | Uint8Array): boolean => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n\n/**\n * Returns `true` if the provided `url` string looks like a valid IPNS subdomain\n * (CIDv1 with `libp2p-key` multicodec or something that looks like a FQDN, for\n * example `en.wikipedia-on-ipfs.org.ipns.localhost:8080`) or `false` otherwise.\n *\n * **Note:** `ipnsSubdomain` method works in offline mode: it does not perform\n * actual IPNS record lookup over DHT or other content routing method. It may\n * return false-positives:\n *\n * - To ensure IPNS record  exists, make a call to `/api/v0/name/resolve?arg=<ipnsid>`\n * - To ensure DNSLink exists, make a call to `/api/v0/dns?arg=<fqdn>`\n */\nexport const ipnsSubdomain = (url: string | Uint8Array): boolean => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS, looks like\n * an IPNS/DNSLink subdomain or `false` otherwise.\n */\nexport const subdomain = (url: string | Uint8Array): boolean => ipfsSubdomain(url) || ipnsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPFS url or `false`\n * otherwise.\n */\nexport const ipfsUrl = (url: string | Uint8Array): boolean => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPNS url or `false`\n * otherwise.\n */\nexport const ipnsUrl = (url: string | Uint8Array): boolean => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or `false`\n * otherwise.\n */\nexport const url = (url: string | Uint8Array): boolean => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\nexport const path = (path: string | Uint8Array): boolean => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\n/**\n * Returns `true` if the provided string or `Uint8Array`  is a valid `multihash`\n * or `false` otherwise.\n */\nexport { isMultihash as multihash }\n\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid multiaddr or `false` otherwise.\n */\nexport { isMultiaddr as multiaddr }\n\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid libp2p peer multiaddr (matching [`P2P`\n * format from `mafmt`](https://github.com/multiformats/js-mafmt#api)) or\n * `false` otherwise.\n */\nexport { isPeerMultiaddr as peerMultiaddr }\n\n/**\n * Returns `true` if the provided string, `Uint8Array` or [`CID`](https://github.com/multiformats/js-multiformats/#readme)\n * object represents a valid [CID](https://docs.ipfs.io/guides/concepts/cid/) or\n * `false` otherwise.\n */\nexport { isCID as cid }\n\n/**\n * Returns `true` if the provided string is a valid `CID` in Base32 encoding or\n * `false` otherwise.\n */\nexport const base32cid = (cid: CID | string | Uint8Array): boolean => (isCID(cid) && isBase32EncodedMultibase(cid))\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS path or `false`\n * otherwise.\n */\nexport const ipfsPath = (path: string | Uint8Array): boolean => isIpfs(path, pathPattern)\n\n/**\n * Returns `true` if the provided string is a valid IPNS path or `false`\n * otherwise.\n */\nexport const ipnsPath = (path: string | Uint8Array): boolean => isIpns(path, pathPattern)\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or path or\n * `false` otherwise.\n */\nexport const urlOrPath = (x: string | Uint8Array): boolean => url(x) || path(x)\n\n/**\n * Returns `true` if the provided string is a valid \"CID path\" (IPFS path\n * without `/ipfs/` prefix) or `false` otherwise.\n */\nexport const cidPath = (path: string | Uint8Array | CID): boolean => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n"],"names":["URLWithLegacySupport","format","URLSearchParams","defaultBase","require","relative","module","exports","URL","url","urlParsed","location","arguments","length","undefined","protocolMap","defaultProtocol","protocol","replace","err","base","Object","assign","host","toString","isReactNative","navigator","product","self","constructor","this","super","path","pathname","search","auth","username","password","query","startsWith","slice","hash","hostname","href","origin","port","searchParams","createObjectURL","o","revokeObjectURL","toJSON","obj","userPass","Uint8Array","coerce","name","ArrayBuffer","isView","buffer","byteOffset","byteLength","Error","src","ALPHABET","TypeError","BASE_MAP","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","size","b256","carry","it3","it4","vch","encode","Array","isArray","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","Encoder","prefix","baseEncode","bytes","Decoder","baseDecode","prefixCodePoint","codePointAt","text","JSON","stringify","or","decoder","ComposedDecoder","decoders","input","RangeError","keys","left","right","Codec","encoder","_ref","baseX","_ref2","alphabet","basex","rfc4648","_ref3","bitsPerChar","data","pad","mask","out","bits","codes","end","written","value","SyntaxError","base58btc","base58flickr","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","base36","base36upper","encode_1","num","offset","oldOffset","INT","MSB","MSBALL","pow","read","buf","b","res","shift","counter","l","REST$1","MSB$1","N1","N2","N3","N4","N5","N6","N7","N8","N9","encodingLength","varint","encodeTo","int","target","create","code","digest","sizeOffset","digestOffset","set","Digest","multihash","subarray","link","version","cache","cid","get","toStringV0","baseCache","toStringV1","WeakMap","Map","CID","asCID","toV0","DAG_PB_CODE","SHA_256_CODE","createV0","toV1","createV1","equals","other","unknown","a","aa","bb","ii","equalBytes","Symbol","toStringTag","for","encodeCID","cidSymbol","remainder","decodeFirst","specs","inspectBytes","prefixSize","multihashSize","multihashBytes","digestBytes","digestSize","multihashCode","codec","initialBytes","next","parse","parseCIDtoBytes","codeOffset","hashOffset","base10","base16","base16upper","base2","alphabetBytesToChars","reduce","p","c","alphabetCharsToBytes","codePoint","base256emoji","byts","char","byt","push","base64","base64pad","base64url","base64urlpad","base8","identity","TextDecoder","TextEncoder","fromString","textEncoder","textDecoder","node","Hasher","result","then","sha","async","crypto","subtle","sha256","sha512","bases","identityBase","base58","allocUnsafe","createCodec","substring","ascii","String","fromCharCode","utf8","hex","latin1","binary","array","encoding","REST","Number","MAX_SAFE_INTEGER","encodeUint8Array","encodeUint8ArrayList","decodeUint8Array","decodeUint8ArrayList","concat","arrays","acc","curr","output","arr","parser","index","new","readAtomically","fn","parseWith","peekChar","readChar","readGivenChar","readSeparator","sep","inner","readNumber","radix","maxDigits","allowZeroPrefix","maxBytes","digitCount","leadingChar","hasLeadingZero","maxValue","digit","parseInt","isNaN","readIPv4Addr","ix","readIPv6Addr","readGroups","groups","ipv4","group","head","headSize","headIp4","tail","limit","tailSize","readIPAddr","isIPv4","Boolean","parseIPv4","isIPv6","includes","split","parseIPv6","isIP","parseIP","isV4","isV6","toBytes","ip","trim","forEach","byte","sections","v4Buffer","uint8ArrayToString","splice","unshift","argv","apply","word","V","names","getProtocol","proto","row","resolvable","createProtocol","convertToString","ipBuff","ipString","view","DataView","join","getUint16","bytes2ip","bytes2str","bytes2port","address","bytes2mh","bytes2onion","bytes2mb","globalThis","encodeURIComponent","convertToBytes","ip2bytes","str2bytes","port2bytes","mh","uint8ArrayConcat","mh2bytes","addr","portBuf","onion2bytes","onion32bytes","mbstr","mb","anybaseDecoder","mb2bytes","decodeURIComponent","uint8ArrayFromString","values","map","d","setUint16","addrBytes","portBytes","bytesToMultiaddrParts","tuples","stringTuples","n","sizeForAddr","ParseError","stringAddr","stringTuplesToString","parts","tup","cleanPath","tuplesToBytes","filter","inspect","symbol","DNS_CODES","NoAvailableResolverError","Multiaddr","stringToMultiaddrParts","isMultiaddr","toOptions","family","transport","zone","tcp","udp","ip4","ip6","dns6","ip6zone","protos","protoCodes","protoNames","encapsulate","decapsulate","addrString","s","lastIndexOf","decapsulateCode","getPeerId","_ref4","p2p","tuple","pop","peerIdStr","e","getPath","uint8ArrayEquals","resolve","options","resolvableProto","find","resolver","resolvers","multiaddr","nodeAddress","isThinWaistAddress","MultiaddrClass","DNS4","DNS6","DNSADDR","DNS","IP","TCP","and","UDP","UTP","QUIC","QUICV1","_WebSockets","WebSockets","_WebSocketsSecure","WebSocketsSecure","HTTP","HTTPS","_WebRTCDirect","WebRTCDirect","_WebTransport","WebTransport","P2PWebRTCStar","P2PWebRTCDirect","Reliable","_P2P","_Circuit","CircuitRecursive","Circuit","P2P","makeMatchesFunction","partialMatch","ma","_len","args","_key","some","arg","matches","_len2","_key2","pnames","pathGatewayPattern","pathPattern","subdomainGatewayPattern","fqdnWithTld","isMultihash","formatted","isCID","isString","isPeerMultiaddr","mafmt","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","ipnsId","test","ipfsSubdomain","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","base32cid","isBase32EncodedMultibase","ipfsPath","ipnsPath","urlOrPath","cidPath"],"sourceRoot":""}